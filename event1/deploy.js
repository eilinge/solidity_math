//eve.sol
/*pragma solidity ^0.5.0;

contract ClientReceipt {
    event Deposit(
        address indexed _from,
        bytes32 indexed _id,
        uint _value
    );

    function deposit(bytes32 _id) payable public {
        // Any call to this function (even deeply nested) can
        // be detected from the JavaScript API by filtering
        // for `Deposit` to be called.
        emit Deposit(msg.sender, _id, msg.value);
    }
}
*/
// solcjs --abi --bin eve.sol
//eve_sol_ClientReceipt.abi eve_sol_ClientReceipt.bin

var Web3 = require('./../../web3');
var fs = require('fs');
// var require('index.js')

//var web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:9545'));
//var web3 = new Web3(new Web3.httpprovider.HttpProvider('http://localhost:9545'));
if (typeof web3 !== 'undefined') {
        web3 = new Web3(web3.currentProvider);
    } else {
        // set the provider you want from Web3.providers
        //web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:9545"));
        web3 = new Web3(new Web3.httpprovider.HttpProvider("http://localhost:9545"));
    }
// var web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:9545"));


// var abi = [{"constant":false,"inputs":[{"name":"_id","type":"bytes32"}],"name":"deposit","outputs":[],"payable":true,"stateMutability":"payable","type":"function"},
// {"anonymous":false,"inputs":[{"indexed":true,"name":"_from","type":"address"},{"indexed":true,"name":"_id","type":"bytes32"},
// {"indexed":false,"name":"_value","type":"uint256"}],"name":"Deposit","type":"event"}]/* abi as generated by the compiler */;
var abi = JSON.parse(fs.readFileSync("eve_sol_ClientReceipt.abi"));

var ClientReceipt = web3.eth.Contract(abi);
var clientReceipt = ClientReceipt.at("0xca35b7d915458ef540ade6068dfe2f44e8fa733c" /* address */);

var event = clientReceipt.Deposit();
/*
事件是使用EVM日志内置功能的方便工具，在DAPP的接口中，它可以反过来调用Javascript的监听事件的回调。
事件在合约中可被继承。当被调用时，会触发参数存储到交易的日志中（一种区块链上的特殊数据结构）。这些日志与合约的地址关联，并合并到区块链中，
只要区块可以访问就一直存在(至少Frontier，Homestead是这样，但Serenity也许也是这样)。日志和事件在合约内不可直接被访问，即使是创建日志的合约。
日志的SPV(简单支付验证)是可能的，如果一个外部的实体提供了一个这样证明的合约，它可以证明日志在区块链是否存在。但需要留意的是，由于合约中仅能访问最近的256个区块哈希，所以还需要提供区块头信息。
可以最多有三个参数被设置为indexed，来设置是否被索引。设置为索引后，可以允许通过这个参数来查找日志，甚至可以按特定的值过滤。对于匿名事件无法通过名字来过滤。
*/
// watch for changes
event.watch(function(error, result){
    // result will contain various information
    // including the argumets given to the Deposit
    // call.
    //通过函数log0，log1，log2，log3，log4，可以直接访问底层的日志组件。logi表示总共有带i + 1个参数
    if (!error)
        console.log(result);
});

// Or pass a callback to start watching immediately
var event = clientReceipt.Deposit(function(error, result) {
    if (!error)
        console.log(result);
});

//node deployed.js
